<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Session Timer with Qualtrics Intercept</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #survey-iframe { 
            width: 100%; 
            height: 500px; 
            border: 1px solid #ccc; 
        }
        #timer-popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #f0f0f0;
            padding: 20px;
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            z-index: 9999999999999999999;
            display: none;
            width: 300px;
        }
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 2000000002;
            display: none;
        }
    </style>
</head>

<body>
    <h1>Main Website</h1>
    <p>This page contains a survey in an iframe and a timer popup that may interrupt.</p>
    
    <iframe id="survey-iframe" src="https://zn9bwreamgwdwatnf-wellsfargocxsandbox.siteintercept.qualtrics.com/SIE/?Q_ZID=ZN_9BwReAmgWdWatNf" title="Survey Form"></iframe>
    
    <div class="overlay" id="overlay"></div>
    <div id="timer-popup">
        <h2>Important Notice!</h2>
        <p>Your session is about to expire. Would you like to extend your session?</p>
        <button id="continue-survey">Continue Survey</button>
    </div>
    
    <button id="trigger-popup">Simulate Timed Popup</button>

    <script>
        const overlay = document.getElementById('overlay');
        const popup = document.getElementById('timer-popup');
        const continueBtn = document.getElementById('continue-survey');
        
        let timer;
        const SESSION_TIME = 15000; // 1 minute
        let popupOpen = false;

        function startSessionTimer() {
            timer = setTimeout(showPopup, SESSION_TIME);
        }

        function showPopup() {
            if (!popupOpen) {
                popupOpen = true;
                overlay.style.display = 'block';
                popup.style.display = 'block';
                
                // Focus on the Continue Survey button
                continueBtn.focus();
            }
        }

        function resetTimer() {
            clearTimeout(timer);
            startSessionTimer(); // Restart the session timer
        }

        function closePopup() {
            overlay.style.display = 'none';
            popup.style.display = 'none';
            popupOpen = false;
        }

        function extendSession() {
            // Unload the Qualtrics intercept
            if (typeof QSI !== 'undefined' && QSI.API) {
                QSI.API.unload(); // Unload current intercept
                QSI.API.load(); // Reload the intercept
            }
            closePopup();
            resetTimer(); // Reset the timer when extending session
        }

        // Event listeners for buttons
        continueBtn.addEventListener('click', extendSession);
        document.getElementById('trigger-popup').addEventListener('click', showPopup);

        // Start the session timer when the page loads
        window.onload = function() {
            startSessionTimer();
        };
    </script>

    <!-- Qualtrics Website Feedback Snippet -->
    <script type='text/javascript'>
        (function(){
            var g=function(g){
                this.go=function(){
                    var a=document.createElement("script");
                    a.type="text/javascript";
                    a.src=g; 
                    document.body&&document.body.appendChild(a)
                };
                this.start=function(){
                    var t=this;
                    "complete"!==document.readyState?
                    window.addEventListener?window.addEventListener("load",function(){t.go()},!1):
                    window.attachEvent&&window.attachEvent("onload",function(){t.go()}):t.go()
                };
            };
            try{
                // Qualtrics intercept script with your Q_ZID placeholder
                (new g("https://zn9bwreamgwdwatnf-wellsfargocxsandbox.siteintercept.qualtrics.com/SIE/?Q_ZID=ZN_9BwReAmgWdWatNf")).start();
            } catch(i){
                console.error("Qualtrics intercept loading error: ", i);
            }
        })();
        
//ADA fixes test
        
    document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded fired.');
    const containerDiv = document.querySelector('.QSIWebResponsive');

    if (!containerDiv) {
        console.error("Container div with selector '.QSIWebResponsive' not found.");
        return;
    }
    console.log('Container div found:', containerDiv);

    // Assuming the iframe is a descendant of the container div
    const iframe = containerDiv.querySelector('iframe[name="survey-iframe-SI_8Jna9K5PTcSmf3w"]');

    if (!iframe) {
        console.error("Iframe with name 'survey-iframe-SI_8Jna9K5PTcSmf3w' not found within the container div.");
        // Continue execution even if iframe is not found, maybe the container itself is enough
        // return; // Removed return to allow observer to start even if iframe isn't there yet
    }
    console.log('Iframe found:', iframe || 'Not found within container yet.');


    const originalStates = new Map();

    const applyRestrictions = () => {
      console.log('applyRestrictions called.');
      // Hide all direct children of body *except* the container div and its descendants
      const elementsToHide = Array.from(document.querySelectorAll('body > *'))
        .filter(element => element !== containerDiv && !containerDiv.contains(element));
      console.log('Elements to hide:', elementsToHide.length, elementsToHide);

      elementsToHide.forEach(element => {
        // Only store if not already hidden or tabindex -1 by something else
        if (element.getAttribute('aria-hidden') !== 'true' || element.getAttribute('tabindex') !== '-1') {
            originalStates.set(element, {
              ariaHidden: element.getAttribute('aria-hidden'),
              tabindex: element.getAttribute('tabindex')
            });
            element.setAttribute('aria-hidden', 'true');
            element.setAttribute('tabindex', '-1');
        } else {
             // Element already seems restricted, don't store/modify
             console.log('Skipping element already restricted:', element);
        }
      });
      // Store the map of original states keyed by element reference
      window.__originalAccessibilityStates = originalStates;
      console.log('Restrictions applied to elements outside the container.', originalStates.size, 'elements modified.');
    };

    const removeRestrictions = () => {
      console.log('removeRestrictions called.');
      const storedStates = window.__originalAccessibilityStates; // Access the stored map
      if (storedStates instanceof Map && storedStates.size > 0) { // Check if storedStates is a Map and not empty
        console.log('Restoring accessibility states for', storedStates.size, 'elements.');
        storedStates.forEach((state, element) => {
          // Check if the element is still in the DOM before trying to modify it
          // Use document.body.contains for a more robust check
          if (document.body.contains(element)) {
            console.log('Restoring state for:', element, 'Original state:', state);
            if (state.ariaHidden === null) {
              element.removeAttribute('aria-hidden');
            } else {
              element.setAttribute('aria-hidden', state.ariaHidden);
            }

            if (state.tabindex === null) {
              element.removeAttribute('tabindex');
            } else {
              element.setAttribute('tabindex', state.tabindex);
            }
          } else {
              console.warn('Attempted to restore state for element no longer in DOM:', element);
          }
        });
        // Clear the stored states from the window object after restoring
        delete window.__originalAccessibilityStates;
        console.log('Restrictions removed from elements outside the container. Stored states cleared.');
      } else {
          console.log('No stored accessibility states to remove.');
          // If there were no stored states, it means applyRestrictions might not have run,
          // or it ran but found no elements to hide.
      }
       // Clear the map reference even if it was empty or not a Map, to ensure cleanup
       window.__originalAccessibilityStates = new Map(); // Reset or delete as appropriate
    };


    // We now observe the containerDiv for *any* attribute changes
    const observer = new MutationObserver((mutationsList, observer) => {
      console.log('MutationObserver callback fired.', mutationsList);
      let visibilityChanged = false; // Flag to avoid redundant checks/calls

      for (const mutation of mutationsList) {
        console.log('Processing mutation:', mutation.type, mutation.target, mutation.attributeName);
        // Check if the mutation is on the containerDiv and involves attributes
        // We are now observing ALL attributes, so check if *any* attribute change occurred on the target
        if (mutation.target === containerDiv && mutation.type === 'attributes') {
           console.log('Attributes changed on container div.');
           visibilityChanged = true; // An attribute changed, let's check visibility state after the loop
           // If you wanted to be more specific, you could check mutation.attributeName === 'class'
           // but observing all attributes is safer if the method of control isn't just 'class'.
        }
        // You could also add checks for changes in subtree if necessary, but let's start with attributes.
      }

      // After processing all mutations in this batch, check the current computed style if relevant attributes changed
      if (visibilityChanged) {
           const display = window.getComputedStyle(containerDiv).display;
           const visibility = window.getComputedStyle(containerDiv).visibility;
           const opacity = window.getComputedStyle(containerDiv).opacity; // Consider opacity as well
           console.log('Container div computed style after relevant attribute change:', {display, visibility, opacity});

           const isCurrentlyVisible = (display !== 'none' && visibility !== 'hidden' && opacity !== '0'); // Check display, visibility, and opacity
           // Retrieve the previous state using the data attribute
           const wasPreviouslyVisible = containerDiv.dataset.wasVisible === 'true';

           console.log('Visibility state:', {isCurrentlyVisible, wasPreviouslyVisible});

           if (isCurrentlyVisible && !wasPreviouslyVisible) {
             console.log('Container div became visible. Applying restrictions.');
             applyRestrictions();
             containerDiv.dataset.wasVisible = 'true'; // Update state
           } else if (!isCurrentlyVisible && wasPreviouslyVisible) {
             console.log('Container div became hidden. Removing restrictions.');
             removeRestrictions();
             containerDiv.dataset.wasVisible = 'false'; // Update state
           }
      }
    });

    // Initial check and setup of the data attribute before starting the observer
    const initialDisplay = window.getComputedStyle(containerDiv).display;
    const initialVisibility = window.getComputedStyle(containerDiv).visibility;
    const initialOpacity = window.getComputedStyle(containerDiv).opacity;
    const isInitiallyVisible = (initialDisplay !== 'none' && initialVisibility !== 'hidden' && initialOpacity !== '0');
    containerDiv.dataset.wasVisible = isInitiallyVisible.toString(); // Initialize state tracking
    console.log('Initial container div computed style on load:', {initialDisplay, initialVisibility, initialOpacity, isInitiallyVisible});

    if (isInitiallyVisible) {
      console.log('Container div initially visible. Applying restrictions on load.');
      applyRestrictions();
    } else {
      console.log('Container div not initially visible, restrictions not applied on load.');
    }


    // Start observing the containerDiv for any attribute changes (class, style, etc.)
    console.log('Starting MutationObserver on container div attributes.');
    observer.observe(containerDiv, { attributes: true }); // Watch for any attribute changes
    // Consider adding subtree: true if changes happen to children that affect container visibility
    observer.observe(containerDiv, { attributes: true, subtree: true }); // More comprehensive but potentially less performant

});

    </script>
    <div id='ZN_9BwReAmgWdWatNf'><!--DO NOT REMOVE-CONTENTS PLACED HERE--></div>
</body>

</html>
